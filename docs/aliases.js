var ALIASES = {};
ALIASES['adler32'] = {};
ALIASES['adler32'] = {};
ALIASES['aho_corasick'] = {};
ALIASES['aho_corasick'] = {};
ALIASES['argparse'] = {};
ALIASES['argparse'] = {};
ALIASES['arrayvec'] = {};
ALIASES['arrayvec'] = {};
ALIASES['base64'] = {};
ALIASES['base64'] = {};
ALIASES['bincode'] = {};
ALIASES['bincode'] = {};
ALIASES['byteorder'] = {};
ALIASES['byteorder'] = {};
ALIASES['bytes'] = {};
ALIASES['bytes'] = {};
ALIASES['cfg_if'] = {};
ALIASES['cfg_if'] = {};
ALIASES['colored'] = {};
ALIASES['colored'] = {};
ALIASES['core_foundation'] = {};
ALIASES['core_foundation'] = {};
ALIASES['core_foundation_sys'] = {};
ALIASES['core_foundation_sys'] = {};
ALIASES['crc'] = {};
ALIASES['crc'] = {};
ALIASES['crossbeam_deque'] = {};
ALIASES['crossbeam_deque'] = {};
ALIASES['crossbeam_epoch'] = {};
ALIASES['crossbeam_epoch'] = {};
ALIASES['crossbeam_utils'] = {};
ALIASES['crossbeam_utils'] = {};
ALIASES['dtoa'] = {};
ALIASES['dtoa'] = {};
ALIASES['either'] = {};
ALIASES['either'] = {};
ALIASES['encoding'] = {};
ALIASES['encoding'] = {};
ALIASES['encoding_index_japanese'] = {};
ALIASES['encoding_index_japanese'] = {};
ALIASES['encoding_index_korean'] = {};
ALIASES['encoding_index_korean'] = {};
ALIASES['encoding_index_simpchinese'] = {};
ALIASES['encoding_index_simpchinese'] = {};
ALIASES['encoding_index_singlebyte'] = {};
ALIASES['encoding_index_singlebyte'] = {};
ALIASES['encoding_index_tests'] = {};
ALIASES['encoding_index_tests'] = {};
ALIASES['encoding_index_tradchinese'] = {};
ALIASES['encoding_index_tradchinese'] = {};
ALIASES['encoding_rs'] = {};
ALIASES['encoding_rs'] = {};
ALIASES['fallible_iterator'] = {};
ALIASES['fallible_iterator'] = {};
ALIASES['flate2'] = {};
ALIASES['flate2'] = {};
ALIASES['futures'] = {};
ALIASES['futures'] = {};
ALIASES['futures_cpupool'] = {};
ALIASES['futures_cpupool'] = {};
ALIASES['glob'] = {};
ALIASES['glob'] = {};
ALIASES['httparse'] = {};
ALIASES['httparse'] = {};
ALIASES['hyper'] = {};
ALIASES['hyper'] = {};
ALIASES['hyper_tls'] = {};
ALIASES['hyper_tls'] = {};
ALIASES['idna'] = {};
ALIASES['idna'] = {};
ALIASES['iovec'] = {};
ALIASES['iovec'] = {};
ALIASES['itertools'] = {};
ALIASES['itertools'] = {};
ALIASES['itoa'] = {};
ALIASES['itoa'] = {};
ALIASES['language_tags'] = {};
ALIASES['language_tags'] = {};
ALIASES['lazy_static'] = {};
ALIASES['lazy_static'] = {};
ALIASES['lazy_static'] = {};
ALIASES['lazy_static'] = {};
ALIASES['lazycell'] = {};
ALIASES['lazycell'] = {};
ALIASES['libc'] = {};
ALIASES['libc'] = {};
ALIASES['libflate'] = {};
ALIASES['libflate'] = {};
ALIASES['libz_sys'] = {};
ALIASES['libz_sys'] = {};
ALIASES['log'] = {};
ALIASES['log'] = {};
ALIASES['matches'] = {};
ALIASES['matches'] = {};
ALIASES['memchr'] = {};
ALIASES['memchr'] = {};
ALIASES['memmap'] = {};
ALIASES['memmap'] = {};
ALIASES['memoffset'] = {};
ALIASES['memoffset'] = {};
ALIASES['mime'] = {};
ALIASES['mime'] = {};
ALIASES['mime_guess'] = {};
ALIASES['mime_guess'] = {};
ALIASES['mio'] = {};
ALIASES['mio'] = {};
ALIASES['native_tls'] = {};
ALIASES['native_tls'] = {};
ALIASES['net2'] = {};
ALIASES['net2'] = {};
ALIASES['nodrop'] = {};
ALIASES['nodrop'] = {};
ALIASES['nom'] = {"/=":[{'crate':'nom','ty':8,'name':'DivAssign','desc':'The division assignment operator `/=`.','p':'nom::lib::std::ops'}],"..=":[{'crate':'nom','ty':3,'name':'RangeInclusive','desc':'An range bounded inclusively below and above (`start..=end`).','p':'nom::lib::std::ops'},{'crate':'nom','ty':3,'name':'RangeToInclusive','desc':'A range only bounded inclusively above (`..=end`).','p':'nom::lib::std::ops'}],"*":[{'crate':'nom','ty':8,'name':'Mul','desc':'The multiplication operator `*`.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'MulAssign','desc':'The multiplication assignment operator `*=`.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'DerefMut','desc':'Used for mutable dereferencing operations, like in `*v = 1;`.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'Deref','desc':'Used for immutable dereferencing operations, like `*v`.','p':'nom::lib::std::ops'}],">=":[{'crate':'nom','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'nom::lib::std::prelude::v1::v1'},{'crate':'nom','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'nom::lib::std::prelude::v1::v1'}],"^=":[{'crate':'nom','ty':8,'name':'BitXorAssign','desc':'The bitwise XOR assignment operator `^=`.','p':'nom::lib::std::ops'}],">":[{'crate':'nom','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'nom::lib::std::prelude::v1::v1'},{'crate':'nom','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'nom::lib::std::prelude::v1::v1'}],"<=":[{'crate':'nom','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'nom::lib::std::prelude::v1::v1'},{'crate':'nom','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'nom::lib::std::prelude::v1::v1'}],"&=":[{'crate':'nom','ty':8,'name':'BitAndAssign','desc':'The bitwise AND assignment operator `&=`.','p':'nom::lib::std::ops'}],"^":[{'crate':'nom','ty':8,'name':'BitXor','desc':'The bitwise XOR operator `^`.','p':'nom::lib::std::ops'}],"[]":[{'crate':'nom','ty':8,'name':'IndexMut','desc':'Used for indexing operations (`container[index]`) in mutable contexts.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'Index','desc':'Used for indexing operations (`container[index]`) in immutable contexts.','p':'nom::lib::std::ops'}],"+":[{'crate':'nom','ty':8,'name':'Add','desc':'The addition operator `+`.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'AddAssign','desc':'The addition assignment operator `+=`.','p':'nom::lib::std::ops'}],">>=":[{'crate':'nom','ty':8,'name':'ShrAssign','desc':'The right shift assignment operator `>>=`.','p':'nom::lib::std::ops'}],"%":[{'crate':'nom','ty':8,'name':'RemAssign','desc':'The remainder assignment operator `%=`.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'Rem','desc':'The remainder operator `%`.','p':'nom::lib::std::ops'}],"[":[{'crate':'nom','ty':8,'name':'IndexMut','desc':'Used for indexing operations (`container[index]`) in mutable contexts.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'Index','desc':'Used for indexing operations (`container[index]`) in immutable contexts.','p':'nom::lib::std::ops'}],"/":[{'crate':'nom','ty':8,'name':'Div','desc':'The division operator `/`.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'DivAssign','desc':'The division assignment operator `/=`.','p':'nom::lib::std::ops'}],"..":[{'crate':'nom','ty':3,'name':'RangeFull','desc':'An unbounded range (`..`).','p':'nom::lib::std::ops'},{'crate':'nom','ty':3,'name':'RangeFrom','desc':'A range only bounded inclusively below (`start..`).','p':'nom::lib::std::ops'},{'crate':'nom','ty':3,'name':'Range','desc':'A (half-open) range bounded inclusively below and exclusively above (`start..end`).','p':'nom::lib::std::ops'},{'crate':'nom','ty':3,'name':'RangeTo','desc':'A range only bounded exclusively above (`..end`).','p':'nom::lib::std::ops'}],"<<":[{'crate':'nom','ty':8,'name':'Shl','desc':'The left shift operator `<<`. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust\'s type checker has special handling for `_ << _`, setting the result type for integer operations to the type of the left-hand-side operand. This means that though `a << b` and `a.shl(b)` are one and the same from an evaluation standpoint, they are different when it comes to type inference.','p':'nom::lib::std::ops'}],"{}":[{'crate':'nom','ty':8,'name':'Display','desc':'Format trait for an empty format, `{}`.','p':'nom::lib::std::fmt'}],"<":[{'crate':'nom','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'nom::lib::std::prelude::v1::v1'},{'crate':'nom','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'nom::lib::std::prelude::v1::v1'}],"&":[{'crate':'nom','ty':8,'name':'BitAnd','desc':'The bitwise AND operator `&`.','p':'nom::lib::std::ops'}],"*=":[{'crate':'nom','ty':8,'name':'MulAssign','desc':'The multiplication assignment operator `*=`.','p':'nom::lib::std::ops'}],"|=":[{'crate':'nom','ty':8,'name':'BitOrAssign','desc':'The bitwise OR assignment operator `|=`.','p':'nom::lib::std::ops'}],"|":[{'crate':'nom','ty':8,'name':'BitOr','desc':'The bitwise OR operator `|`.','p':'nom::lib::std::ops'}],"&*":[{'crate':'nom','ty':8,'name':'Deref','desc':'Used for immutable dereferencing operations, like `*v`.','p':'nom::lib::std::ops'}],">>":[{'crate':'nom','ty':8,'name':'Shr','desc':'The right shift operator `>>`. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust\'s type checker has special handling for `_ >> _`, setting the result type for integer operations to the type of the left-hand-side operand. This means that though `a >> b` and `a.shr(b)` are one and the same from an evaluation standpoint, they are different when it comes to type inference.','p':'nom::lib::std::ops'}],"-=":[{'crate':'nom','ty':8,'name':'SubAssign','desc':'The subtraction assignment operator `-=`.','p':'nom::lib::std::ops'}],"?":[{'crate':'nom','ty':8,'name':'Try','desc':'A trait for customizing the behavior of the `?` operator.','p':'nom::lib::std::ops'}],"==":[{'crate':'nom','ty':8,'name':'PartialEq','desc':'Trait for equality comparisons which are partial equivalence relations.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'Eq','desc':'Trait for equality comparisons which are equivalence relations.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'Eq','desc':'Trait for equality comparisons which are equivalence relations.','p':'nom::lib::std::prelude::v1::v1'},{'crate':'nom','ty':8,'name':'PartialEq','desc':'Trait for equality comparisons which are partial equivalence relations.','p':'nom::lib::std::prelude::v1::v1'}],"!=":[{'crate':'nom','ty':8,'name':'PartialEq','desc':'Trait for equality comparisons which are partial equivalence relations.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'Eq','desc':'Trait for equality comparisons which are equivalence relations.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'Eq','desc':'Trait for equality comparisons which are equivalence relations.','p':'nom::lib::std::prelude::v1::v1'},{'crate':'nom','ty':8,'name':'PartialEq','desc':'Trait for equality comparisons which are partial equivalence relations.','p':'nom::lib::std::prelude::v1::v1'}],"-":[{'crate':'nom','ty':8,'name':'SubAssign','desc':'The subtraction assignment operator `-=`.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'Neg','desc':'The unary negation operator `-`.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'Sub','desc':'The subtraction operator `-`.','p':'nom::lib::std::ops'}],"+=":[{'crate':'nom','ty':8,'name':'AddAssign','desc':'The addition assignment operator `+=`.','p':'nom::lib::std::ops'}],"{:?}":[{'crate':'nom','ty':8,'name':'Debug','desc':'`?` formatting.','p':'nom::lib::std::fmt'}],"<<=":[{'crate':'nom','ty':8,'name':'ShlAssign','desc':'The left shift assignment operator `<<=`.','p':'nom::lib::std::ops'}],"%=":[{'crate':'nom','ty':8,'name':'RemAssign','desc':'The remainder assignment operator `%=`.','p':'nom::lib::std::ops'}],"]":[{'crate':'nom','ty':8,'name':'IndexMut','desc':'Used for indexing operations (`container[index]`) in mutable contexts.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'Index','desc':'Used for indexing operations (`container[index]`) in immutable contexts.','p':'nom::lib::std::ops'}],};
ALIASES['nom'] = {"/=":[{'crate':'nom','ty':8,'name':'DivAssign','desc':'The division assignment operator `/=`.','p':'nom::lib::std::ops'}],"..=":[{'crate':'nom','ty':3,'name':'RangeInclusive','desc':'An range bounded inclusively below and above (`start..=end`).','p':'nom::lib::std::ops'},{'crate':'nom','ty':3,'name':'RangeToInclusive','desc':'A range only bounded inclusively above (`..=end`).','p':'nom::lib::std::ops'}],"*":[{'crate':'nom','ty':8,'name':'Mul','desc':'The multiplication operator `*`.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'MulAssign','desc':'The multiplication assignment operator `*=`.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'DerefMut','desc':'Used for mutable dereferencing operations, like in `*v = 1;`.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'Deref','desc':'Used for immutable dereferencing operations, like `*v`.','p':'nom::lib::std::ops'}],">=":[{'crate':'nom','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'nom::lib::std::prelude::v1::v1'},{'crate':'nom','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'nom::lib::std::prelude::v1::v1'}],"^=":[{'crate':'nom','ty':8,'name':'BitXorAssign','desc':'The bitwise XOR assignment operator `^=`.','p':'nom::lib::std::ops'}],">":[{'crate':'nom','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'nom::lib::std::prelude::v1::v1'},{'crate':'nom','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'nom::lib::std::prelude::v1::v1'}],"<=":[{'crate':'nom','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'nom::lib::std::prelude::v1::v1'},{'crate':'nom','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'nom::lib::std::prelude::v1::v1'}],"&=":[{'crate':'nom','ty':8,'name':'BitAndAssign','desc':'The bitwise AND assignment operator `&=`.','p':'nom::lib::std::ops'}],"^":[{'crate':'nom','ty':8,'name':'BitXor','desc':'The bitwise XOR operator `^`.','p':'nom::lib::std::ops'}],"[]":[{'crate':'nom','ty':8,'name':'IndexMut','desc':'Used for indexing operations (`container[index]`) in mutable contexts.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'Index','desc':'Used for indexing operations (`container[index]`) in immutable contexts.','p':'nom::lib::std::ops'}],"+":[{'crate':'nom','ty':8,'name':'Add','desc':'The addition operator `+`.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'AddAssign','desc':'The addition assignment operator `+=`.','p':'nom::lib::std::ops'}],">>=":[{'crate':'nom','ty':8,'name':'ShrAssign','desc':'The right shift assignment operator `>>=`.','p':'nom::lib::std::ops'}],"%":[{'crate':'nom','ty':8,'name':'RemAssign','desc':'The remainder assignment operator `%=`.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'Rem','desc':'The remainder operator `%`.','p':'nom::lib::std::ops'}],"[":[{'crate':'nom','ty':8,'name':'IndexMut','desc':'Used for indexing operations (`container[index]`) in mutable contexts.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'Index','desc':'Used for indexing operations (`container[index]`) in immutable contexts.','p':'nom::lib::std::ops'}],"/":[{'crate':'nom','ty':8,'name':'Div','desc':'The division operator `/`.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'DivAssign','desc':'The division assignment operator `/=`.','p':'nom::lib::std::ops'}],"..":[{'crate':'nom','ty':3,'name':'RangeFull','desc':'An unbounded range (`..`).','p':'nom::lib::std::ops'},{'crate':'nom','ty':3,'name':'RangeFrom','desc':'A range only bounded inclusively below (`start..`).','p':'nom::lib::std::ops'},{'crate':'nom','ty':3,'name':'Range','desc':'A (half-open) range bounded inclusively below and exclusively above (`start..end`).','p':'nom::lib::std::ops'},{'crate':'nom','ty':3,'name':'RangeTo','desc':'A range only bounded exclusively above (`..end`).','p':'nom::lib::std::ops'}],"<<":[{'crate':'nom','ty':8,'name':'Shl','desc':'The left shift operator `<<`. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust\'s type checker has special handling for `_ << _`, setting the result type for integer operations to the type of the left-hand-side operand. This means that though `a << b` and `a.shl(b)` are one and the same from an evaluation standpoint, they are different when it comes to type inference.','p':'nom::lib::std::ops'}],"{}":[{'crate':'nom','ty':8,'name':'Display','desc':'Format trait for an empty format, `{}`.','p':'nom::lib::std::fmt'}],"<":[{'crate':'nom','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'nom::lib::std::prelude::v1::v1'},{'crate':'nom','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'nom::lib::std::prelude::v1::v1'}],"&":[{'crate':'nom','ty':8,'name':'BitAnd','desc':'The bitwise AND operator `&`.','p':'nom::lib::std::ops'}],"*=":[{'crate':'nom','ty':8,'name':'MulAssign','desc':'The multiplication assignment operator `*=`.','p':'nom::lib::std::ops'}],"|=":[{'crate':'nom','ty':8,'name':'BitOrAssign','desc':'The bitwise OR assignment operator `|=`.','p':'nom::lib::std::ops'}],"|":[{'crate':'nom','ty':8,'name':'BitOr','desc':'The bitwise OR operator `|`.','p':'nom::lib::std::ops'}],"&*":[{'crate':'nom','ty':8,'name':'Deref','desc':'Used for immutable dereferencing operations, like `*v`.','p':'nom::lib::std::ops'}],">>":[{'crate':'nom','ty':8,'name':'Shr','desc':'The right shift operator `>>`. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust\'s type checker has special handling for `_ >> _`, setting the result type for integer operations to the type of the left-hand-side operand. This means that though `a >> b` and `a.shr(b)` are one and the same from an evaluation standpoint, they are different when it comes to type inference.','p':'nom::lib::std::ops'}],"-=":[{'crate':'nom','ty':8,'name':'SubAssign','desc':'The subtraction assignment operator `-=`.','p':'nom::lib::std::ops'}],"?":[{'crate':'nom','ty':8,'name':'Try','desc':'A trait for customizing the behavior of the `?` operator.','p':'nom::lib::std::ops'}],"==":[{'crate':'nom','ty':8,'name':'PartialEq','desc':'Trait for equality comparisons which are partial equivalence relations.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'Eq','desc':'Trait for equality comparisons which are equivalence relations.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'Eq','desc':'Trait for equality comparisons which are equivalence relations.','p':'nom::lib::std::prelude::v1::v1'},{'crate':'nom','ty':8,'name':'PartialEq','desc':'Trait for equality comparisons which are partial equivalence relations.','p':'nom::lib::std::prelude::v1::v1'}],"!=":[{'crate':'nom','ty':8,'name':'PartialEq','desc':'Trait for equality comparisons which are partial equivalence relations.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'Eq','desc':'Trait for equality comparisons which are equivalence relations.','p':'nom::lib::std::cmp'},{'crate':'nom','ty':8,'name':'Eq','desc':'Trait for equality comparisons which are equivalence relations.','p':'nom::lib::std::prelude::v1::v1'},{'crate':'nom','ty':8,'name':'PartialEq','desc':'Trait for equality comparisons which are partial equivalence relations.','p':'nom::lib::std::prelude::v1::v1'}],"-":[{'crate':'nom','ty':8,'name':'SubAssign','desc':'The subtraction assignment operator `-=`.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'Neg','desc':'The unary negation operator `-`.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'Sub','desc':'The subtraction operator `-`.','p':'nom::lib::std::ops'}],"+=":[{'crate':'nom','ty':8,'name':'AddAssign','desc':'The addition assignment operator `+=`.','p':'nom::lib::std::ops'}],"{:?}":[{'crate':'nom','ty':8,'name':'Debug','desc':'`?` formatting.','p':'nom::lib::std::fmt'}],"<<=":[{'crate':'nom','ty':8,'name':'ShlAssign','desc':'The left shift assignment operator `<<=`.','p':'nom::lib::std::ops'}],"%=":[{'crate':'nom','ty':8,'name':'RemAssign','desc':'The remainder assignment operator `%=`.','p':'nom::lib::std::ops'}],"]":[{'crate':'nom','ty':8,'name':'IndexMut','desc':'Used for indexing operations (`container[index]`) in mutable contexts.','p':'nom::lib::std::ops'},{'crate':'nom','ty':8,'name':'Index','desc':'Used for indexing operations (`container[index]`) in immutable contexts.','p':'nom::lib::std::ops'}],};
ALIASES['num'] = {};
ALIASES['num'] = {};
ALIASES['num_bigint'] = {};
ALIASES['num_bigint'] = {};
ALIASES['num_complex'] = {};
ALIASES['num_complex'] = {};
ALIASES['num_cpus'] = {};
ALIASES['num_cpus'] = {};
ALIASES['num_integer'] = {};
ALIASES['num_integer'] = {};
ALIASES['num_iter'] = {};
ALIASES['num_iter'] = {};
ALIASES['num_rational'] = {};
ALIASES['num_rational'] = {};
ALIASES['num_traits'] = {};
ALIASES['num_traits'] = {};
ALIASES['pdb'] = {};
ALIASES['pdb'] = {};
ALIASES['peinfo'] = {};
ALIASES['peinfo'] = {};
ALIASES['peinfo'] = {};
ALIASES['percent_encoding'] = {};
ALIASES['percent_encoding'] = {};
ALIASES['pesymbols'] = {};
ALIASES['pesymbols'] = {};
ALIASES['pesymbols'] = {};
ALIASES['phf'] = {};
ALIASES['phf'] = {};
ALIASES['phf_shared'] = {};
ALIASES['phf_shared'] = {};
ALIASES['proc_macro2'] = {};
ALIASES['proc_macro2'] = {};
ALIASES['quote'] = {};
ALIASES['quote'] = {};
ALIASES['rand'] = {};
ALIASES['rand'] = {};
ALIASES['regex'] = {};
ALIASES['regex'] = {};
ALIASES['regex_syntax'] = {};
ALIASES['regex_syntax'] = {};
ALIASES['relay'] = {};
ALIASES['relay'] = {};
ALIASES['remove_dir_all'] = {};
ALIASES['remove_dir_all'] = {};
ALIASES['reqwest'] = {};
ALIASES['reqwest'] = {};
ALIASES['rustc_serialize'] = {};
ALIASES['rustc_serialize'] = {};
ALIASES['safemem'] = {};
ALIASES['safemem'] = {};
ALIASES['scoped_tls'] = {};
ALIASES['scoped_tls'] = {};
ALIASES['scopeguard'] = {};
ALIASES['scopeguard'] = {};
ALIASES['security_framework'] = {};
ALIASES['security_framework'] = {};
ALIASES['security_framework_sys'] = {};
ALIASES['security_framework_sys'] = {};
ALIASES['serde'] = {};
ALIASES['serde'] = {};
ALIASES['serde_derive'] = {};
ALIASES['serde_derive'] = {};
ALIASES['serde_json'] = {};
ALIASES['serde_json'] = {};
ALIASES['serde_urlencoded'] = {};
ALIASES['serde_urlencoded'] = {};
ALIASES['siphasher'] = {};
ALIASES['siphasher'] = {};
ALIASES['slab'] = {};
ALIASES['slab'] = {};
ALIASES['syn'] = {};
ALIASES['syn'] = {};
ALIASES['tempdir'] = {};
ALIASES['tempdir'] = {};
ALIASES['thread_local'] = {};
ALIASES['thread_local'] = {};
ALIASES['time'] = {};
ALIASES['time'] = {};
ALIASES['tokio'] = {};
ALIASES['tokio'] = {};
ALIASES['tokio_codec'] = {};
ALIASES['tokio_codec'] = {};
ALIASES['tokio_core'] = {};
ALIASES['tokio_core'] = {};
ALIASES['tokio_executor'] = {};
ALIASES['tokio_executor'] = {};
ALIASES['tokio_fs'] = {};
ALIASES['tokio_fs'] = {};
ALIASES['tokio_io'] = {};
ALIASES['tokio_io'] = {};
ALIASES['tokio_reactor'] = {};
ALIASES['tokio_reactor'] = {};
ALIASES['tokio_service'] = {};
ALIASES['tokio_service'] = {};
ALIASES['tokio_tcp'] = {};
ALIASES['tokio_tcp'] = {};
ALIASES['tokio_threadpool'] = {};
ALIASES['tokio_threadpool'] = {};
ALIASES['tokio_timer'] = {};
ALIASES['tokio_timer'] = {};
ALIASES['tokio_tls'] = {};
ALIASES['tokio_tls'] = {};
ALIASES['tokio_udp'] = {};
ALIASES['tokio_udp'] = {};
ALIASES['try_lock'] = {};
ALIASES['try_lock'] = {};
ALIASES['ucd_util'] = {};
ALIASES['ucd_util'] = {};
ALIASES['unicase'] = {};
ALIASES['unicase'] = {};
ALIASES['unicase'] = {};
ALIASES['unicase'] = {};
ALIASES['unicode_bidi'] = {};
ALIASES['unicode_bidi'] = {};
ALIASES['unicode_normalization'] = {};
ALIASES['unicode_normalization'] = {};
ALIASES['unicode_xid'] = {};
ALIASES['unicode_xid'] = {};
ALIASES['unreachable'] = {};
ALIASES['unreachable'] = {};
ALIASES['url'] = {};
ALIASES['url'] = {};
ALIASES['utf8_ranges'] = {};
ALIASES['utf8_ranges'] = {};
ALIASES['uuid'] = {};
ALIASES['uuid'] = {};
ALIASES['uuid'] = {};
ALIASES['uuid'] = {};
ALIASES['void'] = {};
ALIASES['void'] = {};
ALIASES['want'] = {};
ALIASES['want'] = {};
ALIASES['xori'] = {};
ALIASES['xori'] = {};
ALIASES['xori'] = {};
